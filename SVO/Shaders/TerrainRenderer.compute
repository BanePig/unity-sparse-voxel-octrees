/*

Renderer for cubic chunks. Same as "SimpleRenderer" but chunks can be culled before ray-tracing is done..

*/

#pragma kernel CSMain

#define POINTER_TYPE 0
#define COLOR_VOXEL_TYPE 1
#define EMPTY_VOXEL_TYPE 2

RWTexture2D<float4> result_texture;
RWTexture2D<float> depth_mask;
StructuredBuffer<int> octree_root;
float4x4 camera_to_world;
float4x4 camera_inverse_projection;
float3 octree_pos;
float3 octree_scale;

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateCameraRay(float2 uv) 
{
    float3 origin = mul(camera_to_world, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    origin += octree_scale;
    origin -= octree_pos;
    origin /= octree_scale;
    float3 direction = mul(camera_inverse_projection, float4(uv, 0.0f, 1.0f)).xyz;
    
    direction = mul(camera_to_world, float4(direction, 0.0f)).xyz;
    direction /= octree_scale;
    direction = normalize(direction);

    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    
    return ray;
}

[numthreads(16,16,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    static const int max_depth = 23;
    static const float epsilon = exp2(-max_depth);
    
    // Get the dimensions of the RenderTexture
    // Depth texture is same dimensions
    uint width, height;
    result_texture.GetDimensions(width, height);

    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    // Get the ray from the camera
    Ray ray = CreateCameraRay(uv);
    
    int3 rayDirSign = sign(ray.direction);
    
    // Get intersections of chunk (if hit)
    float root_tmin = max(max(max(
        (1.5 - .5 * rayDirSign.x - ray.origin.x) / ray.direction.x,
        (1.5 - .5 * rayDirSign.y - ray.origin.y) / ray.direction.y),
        (1.5 - .5 * rayDirSign.z - ray.origin.z) / ray.direction.z), 0);
    float root_tmax = min(min(
        (1.5 + .5 * rayDirSign.x - ray.origin.x) / ray.direction.x,
        (1.5 + .5 * rayDirSign.y - ray.origin.y) / ray.direction.y),
        (1.5 + .5 * rayDirSign.z - ray.origin.z) / ray.direction.z
    );
    float3 root_mid = ray.origin + ray.direction * (.5 * (root_tmin + root_tmax));
    
    if(root_tmax < 0 || any(abs(root_mid - 1.5f) > .5) || root_tmin > depth_mask[id.xy]) return;
    
    float3 next_path = clamp(ray.origin + ray.direction * root_tmin, 1.f, asfloat(0x3fffffff));
    
    int stack[max_depth + 1];
    stack[0] = 0;
    int stack_depth = 0;
    float3 stack_path = float3(0, 0, 0);
    
    int max_lod = 23;
    int n = 0;
    do
    {
        if(n++ > 300) break;
        // GET voxel at targetPos
        int differingBits = asint(stack_path.x) ^ asint(next_path.x);
        differingBits |= asint(stack_path.y) ^ asint(next_path.y);
        differingBits |= asint(stack_path.z) ^ asint(next_path.z);
        differingBits &= 0x007fffff;
        int first_set = 23 - firstbithigh(differingBits);
        int depth = min(first_set - 1, stack_depth);
        int ptr = stack[depth];
        int type = octree_root[ptr] >> 30 & 3;
        while(type == POINTER_TYPE && depth < max_lod)
        {
            ptr = octree_root[ptr];
            depth++;
            int xm = asint(next_path.x) >> 23 - depth & 1;
            int ym = asint(next_path.y) >> 23 - depth & 1;
            int zm = asint(next_path.z) >> 23 - depth & 1;
            int child_index = (xm << 2) + (ym << 1) + zm;
            ptr += child_index;
            stack[depth] = ptr;
            type = octree_root[ptr] >> 30 & 3;
        }
        // If max LOD hit, just go to the first voxel in the branch.
        while(type == POINTER_TYPE)
        {
            ptr++;
            if(octree_root[ptr] >> 30 == POINTER_TYPE)
                ptr = octree_root[ptr] & 0x3FFFFFFF;
            type = octree_root[ptr] >> 30 & 3;
        }
        stack_depth = depth;
        next_path = asfloat(asint(next_path) & ~((1 << 23 - depth) - 1));
        stack_path = next_path;
        
        // DRAW if voxel is solid 
        if(type == COLOR_VOXEL_TYPE)
        {
            int color_rgb = octree_root[ptr];
            float4 color = float4((color_rgb >> 16 & 0xFF) / 255.f, (color_rgb >> 8 & 0xFF) / 255.f, (color_rgb & 0xFF) / 255.f, 1.f);
            result_texture[id.xy] = color;
            depth_mask[id.xy] = root_tmin;
            break;
        }
        
        // STEP to next voxel (Updates nextPath)
        float x_far = rayDirSign.x == 1 ? asfloat(asint(next_path.x) + (1 << 23 - depth)) : next_path.x;
        float y_far = rayDirSign.y == 1 ? asfloat(asint(next_path.y) + (1 << 23 - depth)) : next_path.y;
        float z_far = rayDirSign.z == 1 ? asfloat(asint(next_path.z) + (1 << 23 - depth)) : next_path.z;
        float tx_max = (x_far - ray.origin.x) / ray.direction.x;
        float ty_max = (y_far - ray.origin.y) / ray.direction.y;
        float tz_max = (z_far - ray.origin.z) / ray.direction.z;
        float t_max = tx_max;
        
        if(ty_max < t_max) {
            if(tz_max < ty_max) {
                t_max = tz_max;
                next_path = ray.origin + ray.direction * t_max;
                if(rayDirSign.z == 1) next_path.z = z_far;
                else next_path.z = z_far - epsilon;
            }
            else {
                t_max = ty_max;
                next_path = ray.origin + ray.direction * t_max;
                if(rayDirSign.y == 1) next_path.y = y_far;
                else next_path.y = y_far - epsilon;
            }
        }
        else if(tz_max < t_max) {
            t_max = tz_max;
            next_path = ray.origin + ray.direction * t_max;
            if(rayDirSign.z == 1) next_path.z = z_far;
            else next_path.z = z_far - epsilon;
        }
        else {
            t_max = tx_max;
            next_path = ray.origin + ray.direction * t_max;
            if(rayDirSign.x == 1) next_path.x = x_far;
            else next_path.x = x_far - epsilon;
        }
        
        max_lod = (int)(23 / (t_max/1 + 1));
    }
    while(all(next_path >= 1.f && next_path < 2.f));
}