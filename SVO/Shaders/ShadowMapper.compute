#pragma kernel cs_main

#define POINTER_TYPE 0
#define COLOR_VOXEL_TYPE 1
#define EMPTY_VOXEL_TYPE 2

// Textures
RWTexture2D<float4> diffuse_texture;
RWTexture2D<float3> position_texture;
RWTexture2D<float3> normal_texture;
RWTexture2D<float> shadow_texture;

// Octree Data
StructuredBuffer<int> octree_primary_data;

// Camera data
float3 octree_pos;
float3 octree_scale;

float3 sun_direction;

float3 cam_pos;

struct ray
{
    float3 origin;
    float3 direction;
};

struct ray_hit
{
    float distance;
    float3 position;
    float3 normal;
};

[numthreads(16,16,1)]
void cs_main(uint3 id : SV_DispatchThreadID)
{
    static const int max_depth = 23;
    static const float epsilon = exp2(-max_depth);
    
    // Dimensions of all non-shadow textures
    uint width, height;
    diffuse_texture.GetDimensions(width, height);

    // Dimensions of shadow texture
    uint shadow_tex_width, shadow_tex_height;
    shadow_texture.GetDimensions(shadow_tex_width, shadow_tex_height);

    uint3 scaled_id = uint3(width * id.x / shadow_tex_width, height * id.y / shadow_tex_height, 0);

    ray ray;
    ray.direction = -sun_direction;
    ray.direction /= octree_scale;
    ray.direction = normalize(ray.direction);
    ray.origin = position_texture[scaled_id.xy] + normal_texture[scaled_id.xy] * 0.05f * octree_scale;
    ray.origin += octree_scale;
    ray.origin -= octree_pos;
    ray.origin /= octree_scale;
    
    // Mirror coordinate system such that all ray direction components are negative.
    int sign_mask = 0;
    if(ray.direction.x > 0.f) sign_mask ^= 4, ray.origin.x = 3.f - ray.origin.x;
    if(ray.direction.y > 0.f) sign_mask ^= 2, ray.origin.y = 3.f - ray.origin.y;
    if(ray.direction.z > 0.f) sign_mask ^= 1, ray.origin.z = 3.f - ray.origin.z;

    ray.direction = -abs(ray.direction);
    
    // Get intersections of chunk (if hit)
    float3 root_min_distances = (2.f - ray.origin) / ray.direction;
    float3 root_max_distances = (1.f - ray.origin) / ray.direction;
    float root_tmin = max(max(max(root_min_distances.x, root_min_distances.y), root_min_distances.z), 0);
    float root_tmax = min(min(root_max_distances.x, root_max_distances.y), root_max_distances.z);
    
    if(root_tmax < 0 || root_tmin >= root_tmax || shadow_texture[id.xy] == 0.f) return;
    
    float3 next_path = clamp(ray.origin + ray.direction * root_tmin, 1.f, asfloat(0x3fffffff));
    
    int stack[max_depth + 1];
    stack[0] = 0;
    int stack_depth = 0;
    float3 stack_path = float3(1, 1, 1);
    
    do
    {
        // GET voxel at targetPos
        int differing_bits = asint(stack_path.x) ^ asint(next_path.x);
        differing_bits |= asint(stack_path.y) ^ asint(next_path.y);
        differing_bits |= asint(stack_path.z) ^ asint(next_path.z);
        int first_set = 23 - firstbithigh(differing_bits);
        int depth = min(first_set - 1, stack_depth);
        int ptr = stack[depth];
        int type = octree_primary_data[ptr].x >> 30 & 3;
        while(type == POINTER_TYPE)
        {
            ptr = octree_primary_data[ptr].x;
            depth++;
            int xm = asint(next_path.x) >> 23 - depth & 1;
            int ym = asint(next_path.y) >> 23 - depth & 1;
            int zm = asint(next_path.z) >> 23 - depth & 1;
            int child_index = (xm << 2) + (ym << 1) + zm;
            child_index ^= sign_mask;
            ptr += child_index;
            stack[depth] = ptr;
            type = octree_primary_data[ptr].x >> 30 & 3;
        }
        stack_depth = depth;
        next_path = asfloat(asint(next_path) & ~((1 << 23 - depth) - 1)); // Remove unused bits from next_path
        stack_path = next_path;
        
        // DRAW if voxel is solid
        if(type == COLOR_VOXEL_TYPE)
        {
            shadow_texture[id.xy] = 0.f;
            break;
        }

        // Get ray hit on far side of voxel.
        float x_far = next_path.x;
        float y_far = next_path.y;
        float z_far = next_path.z;
        float tx_max = (x_far - ray.origin.x) / ray.direction.x;
        float ty_max = (y_far - ray.origin.y) / ray.direction.y;
        float tz_max = (z_far - ray.origin.z) / ray.direction.z;
        float t_max = min(min(tx_max, ty_max), tz_max);
        next_path = clamp(ray.origin + ray.direction * t_max, next_path, asfloat(asint(next_path) + (1 << 23 - depth) - 1));

        if(tx_max <= t_max) next_path.x = x_far - epsilon;
        if(ty_max <= t_max) next_path.y = y_far - epsilon;
        if(tz_max <= t_max) next_path.z = z_far - epsilon;
    }
    while(all((asint(next_path) & 0xFF800000) == 0x3f800000));
}
